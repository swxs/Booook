# 七周七并发

------
- [七周七并发](#七周七并发)
  - [并行or并发](#并行or并发)
  - [锁模型](#锁模型)
  - [函数式编程](#函数式编程)
    - [Future 模型](#future-模型)
    - [Promise 模型](#promise-模型)
    - [Clojure之道——分离标识与状态](#clojure之道分离标识与状态)
  - [Actor](#actor)
  - [资料](#资料)

------

## 并行or并发

* 并发程序含有多个逻辑上的独立执行块，它们可以独立地并行执行，也可以串行执行。
* 并行程序解决问题的速度往往比串行程序快得多，因为其可以同时执行整个任务的多个部分。并行程序可能有多个独立执行块，也可能仅有一个。

* 并发是同一时间应对（dealing with）多件事情的能力；
* 并行是同一时间动手做（doing）多件事情的能力。


## 锁模型

*线程与锁模型其实是对底层硬件运行过程的形式化。这种形式化既是该模型最大的优点，也是它最大的缺点。*

*线程与锁模型的最大优点是其适用面很广。它是本书介绍的其他许多技术的基础，适用于解决很多类型的问题。同时，线程与锁模型更接近于“本质”——近似于对硬件工作方式的形式化——正确使用时，其效率很高。*

互斥————用锁保证某一时间仅有一个线程可以访问数据，可能导致竞态条件和死锁。

- 编译器的静态优化可以打乱代码的执行顺序；
- JVM的动态优化也会打乱代码的执行顺序；
- 硬件可以通过乱序执行来优化其性能。

Java内存模型定义了何时一个线程对内存的修改对另一个线程可见。基本原则是，如果读线程和写线程不进行同步，就不能保证可见性。

同步的方法：
- 通过获取对象的内置锁
- 使用ReentrantLock（可中断、可以设置超时、显示加锁解锁、支持条件变量）
- 原子变量

让多线程代码安全运行的方法只能是让所有的方法都同步。然而，这也会带来问题。首先这样做效率低下。如果每个方法都同步，大多数线程会频繁阻塞，使程序失去了并发的意义。问题不止于此，当使用多把锁时（Java中每一个对象都有自己的内置锁），线程之间可能发生死锁。

解决死锁的方案：
- 总是按照一个全局的固定的顺序获取多把锁
- 避免持有锁时调用外星方法
  - 遍历之前对可迭代对象进行保护性复制，再针对这份副本进行遍历
  - 写入时复制
- 持有锁的时间应尽可能短

## 函数式编程

函数式编程与命令式编程（Imperative Programming）不同。命令式编程的代码由一系列改变全局状态的语句构成，而函数式编程则是将计算过程抽象成表达式求值。这些表达式由纯数学函数构成，而这些数学函数是第一类对象，并且没有副作用。由于没有副作用，函数式编程可以更容易做到线程安全，因此特别适合于并发编程。

- 不使用可变状态
- 引用透明性

### Future 模型

### Promise 模型

### Clojure之道——分离标识与状态

## Actor

actor模型保留了可变状态，只是不进行共享


## 资料
* 非公平锁与公平锁: [https://www.jianshu.com/p/f584799f1c77](https://www.jianshu.com/p/f584799f1c77)
* 虚假唤醒（spurious wakeup）[https://www.jianshu.com/p/0eff666a4875](https://www.jianshu.com/p/0eff666a4875)
* Fork-join模型[https://zh.wikipedia.org/wiki/Fork-join%E6%A8%A1%E5%9E%8B](https://zh.wikipedia.org/wiki/Fork-join%E6%A8%A1%E5%9E%8B)
* 阿姆达尔定律: [https://zh.wikipedia.org/wiki/%E9%98%BF%E5%A7%86%E8%BE%BE%E5%B0%94%E5%AE%9A%E5%BE%8B](https://zh.wikipedia.org/wiki/%E9%98%BF%E5%A7%86%E8%BE%BE%E5%B0%94%E5%AE%9A%E5%BE%8B)
